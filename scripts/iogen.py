# Copyright 2023 ETH Zurich and University of Bologna.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Author: Yvan Tortorella <yvan.tortorella@unibo.it>

import csv
import os
import pandas
import sys
from pandas import *

current_dir = os.getcwd()

if len(sys.argv) > 1:
    astral_padring_csv  = sys.argv[1]
else:
    astral_padring_csv = 'padring.csv'

if len(sys.argv) > 2:
    astral_io_file = sys.argv[2]
else:
    astral_io_file = 'astral.io'

# Enable prints for debugging purposes
debug_print = True

pitch = 80.0000
corner_width = 85.000
vertical_width = 10.000
horizontal_width = 10.000
num_fillers = 1

# Vertical/horizontal refers to the pads orientation.
# Vertical offset: offset of all vertical pads (on horizontal edges)
# Horizontal offset: offset of all horizontal pads (on vertical edges)
vertical_offs = corner_width + num_fillers*vertical_width + 0.5
horizontal_offs = corner_width + num_fillers*horizontal_width + 0.5
horizontal_pitch = pitch
vertical_pitch = pitch

pad_top_list = []
pad_top_offset = []
pad_left_list = []
pad_left_offset = []
pad_bottom_list = []
pad_bottom_offset = []
pad_right_list = []
pad_right_offset = []
pad_corner_list = []

single_tab = "\t"
double_tab = single_tab * 2
triple_tab = single_tab * 3

# Read input CVS with the list of pads
csv = read_csv(astral_padring_csv)
if debug_print:
    print(f"File {astral_padring_csv} contains {len(csv.columns)} columns: {csv.columns.tolist()}\n")

# Declare an emply list to fill with elements not containing NaNs
clean_rows = [None]*len(csv.columns)

for i in range(len(csv.columns)):
    # If a column contains NaN, we remove them
    clean_rows[i] = [x for x in csv[csv.columns[i]].tolist() if not isna(x)]
    if debug_print:
    	print(f"Column {i}: {csv.columns[i]}\n")
    	print(f"Column {csv.columns[i]} contains {len(clean_rows[i])} rows: {clean_rows[i]}\n")

pad_top_offset = str(float(clean_rows[0][0]))
pad_top_list = clean_rows[0][1:len(clean_rows[0])]
pad_left_offset = str(float(clean_rows[1][0]))
pad_left_list = clean_rows[1][1:len(clean_rows[1])]
pad_bottom_offset = str(float(clean_rows[2][0]))
pad_bottom_list = clean_rows[2][1:len(clean_rows[2])]
pad_right_offset = str(float(clean_rows[3][0]))
pad_right_list = clean_rows[3][1:len(clean_rows[3])]
pad_corner_list = clean_rows[4]

if debug_print:
    print(f"Top pad offset is {pad_top_offset}\n")
    print(f"List of top pads: {pad_top_list}\n")
    print(f"Left pad offset is {pad_left_offset}\n")
    print(f"List of left pads: {pad_left_list}\n")
    print(f"Bottom pad offset is {pad_bottom_offset}\n")
    print(f"List of bottom pads: {pad_bottom_list}\n")
    print(f"Right pad offset is {pad_right_offset}\n")
    print(f"List of right pads: {pad_right_list}\n")
    print(f"List of corner pads: {pad_corner_list}\n")

signal_name = []

strip_path = 'i_astral_padframe/i_periph/i_periph_pads'

# Add the fixed template to the Innovus IO file
with open(astral_io_file, 'w') as io_file:
    io_file.write('# Astral IO file.\n')
    io_file.write('# This file is automatically generated.\n')
    io_file.write(f'# To regenerate the IO file, edit the `{astral_padring_csv}` and run `python3 astral_io.py`.\n')
    io_file.write('\n')
    io_file.write('(globals\n')
    io_file.write(single_tab+'version = 3\n')
    io_file.write(single_tab+'io_order = default\n')
    io_file.write(')\n')
    io_file.write('(iopad\n')
    io_file.write(single_tab+'(topright\n')
    io_file.write(double_tab+'(inst name="'+strip_path+'/'+pad_corner_list[0]+'" rel_orientation=R180)\n')
    io_file.write(single_tab+')\n')
    io_file.write(single_tab+'(top\n')
    # Top cells
    for i in range(len(pad_top_list)):
        offset = round(float(pad_top_offset) + i*horizontal_pitch, 3)
        io_file.write(double_tab+'(inst name="'+strip_path+'/'+pad_top_list[i]+'"   offset='+str(offset)+' relorientation=R0)\n')
    io_file.write(single_tab+')\n')
    io_file.write(single_tab+'(topleft\n')
    io_file.write(double_tab+'(inst name="'+strip_path+'/'+pad_corner_list[1]+'" rel_orientation=MX)\n')
    io_file.write(single_tab+')\n')
    io_file.write(single_tab+'(left\n')
    # Left cells
    for i in range(len(pad_left_list)):
        offset = round(float(pad_left_offset) + i*vertical_pitch, 3)
        io_file.write(double_tab+'(inst name="'+strip_path+'/'+pad_left_list[i]+'"   offset='+str(offset)+' relorientation=R0)\n')
    io_file.write(single_tab+')\n')
    io_file.write(single_tab+'(bottomleft\n')
    io_file.write(double_tab+'(inst name="'+strip_path+'/'+pad_corner_list[2]+'" rel_orientation=R0)\n')
    io_file.write(single_tab+')\n')
    io_file.write(single_tab+'(bottom\n')
    # Bottom cells
    for i in range(len(pad_bottom_list)):
        offset = round(float(pad_bottom_offset) + i*horizontal_pitch, 3)
        io_file.write(double_tab+'(inst name="'+strip_path+'/'+pad_bottom_list[i]+'"   offset='+str(offset)+' relorientation=R0)\n')
    io_file.write(single_tab+')\n')
    io_file.write(single_tab+'(bottomright\n')
    io_file.write(double_tab+'(inst name="'+strip_path+'/'+pad_corner_list[3]+'" rel_orientation=MY)\n')
    io_file.write(single_tab+')\n')
    io_file.write(single_tab+'(right\n')
    # Right cells
    for i in range(len(pad_right_list)):
        offset = round(float(pad_right_offset) + i*vertical_pitch, 3)
        io_file.write(double_tab+'(inst name="'+strip_path+'/'+pad_right_list[i]+'"   offset='+str(offset)+' relorientation=R0)\n')
    io_file.write(single_tab+')\n')

    io_file.write(')\n')

print(f"Generated {astral_io_file}.")
